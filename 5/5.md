First thing I'm noticing about the task, the input is more complex this time, hooray! But even so, it will purely be just a thing of writing the function to parse it. So let's get started with it.

I'm going to use the newline as a delimiter. When we encounter the newline symbol, we will stop collecting data from the 2d plane schema that's provided to us and will instead start getting those single-line instructions that follow.

```
map_2d = []
instructions = []
is_instructions = False

with open('input5_1.txt') as inputfile:
    for line in inputfile:
        print(line)
        if line == "\n":
            is_instructions = True
            continue
        if is_instructions:
            instructions.append(line)
        else:
            map_2d.append(line)
    # do something with the input now...
```

That, however, appended the line with the newline symbols as a string at the end, so I added a little detail like: 

`instructions.append(line[0:-1])`

To slice that extra \n symbol out. Same for the map input. Also I added an extra newline at the very end of the input, so that the last command doesn't get cut off improperly.

Now we can proceed with parsing each pile of information. Let's start with the map and deciding how we will model the data. We are clearly looking for a LILO sort of data structure, like a stack. Luckily, lists in Python can be used that way.

` Pythonâ€™s built-in data structure list can be used as a stack. Instead of push(), append() is used to add elements to the top of the stack while pop() removes the element in LIFO order. `
[source](https://www.geeksforgeeks.org/stack-in-python/)

Each column on the 2d map is wide exactly 4 symbols: one opening bracket, one letter, one closing bracket, and one space to separate it from the next one. We also know the number of the columns. So, we can use slicing to get the data we need.

I came up with this pretty function:
```
def parse_2d_input(map_2d):
    # get total number of columns from the bottom line of the 2d map
    column_numbers_row = map_2d[len(map_2d)-1]
    number_of_columns = int(column_numbers_row[len(column_numbers_row)-2])
    
    # columns will be saved in a dict with the key being the number.
    # I consider this the cleanest way as it allows for change if necessary later
    all_columns = {}
    
    # for each column, create a list that we will use as a stack to represent the column
    for i in range (1,number_of_columns+1):
        all_columns[i] = []
    
    # drop the last line as we no longer need it (the one with 1-2-3-4-5...)
    map_2d.pop()
    # since we want to start from the bottom up, reverse the 2d map list container
    map_2d.reverse()
            
    for line in map_2d:
        for j in range (1,number_of_columns+1):
            first_4 = line[:4]
            if first_4[1] != " ":
                all_columns[j].append(first_4[1])
            line = line[4:]
            
    return all_columns
```

Which returns us this beautiful result:

```
{1: ['D', 'M', 'S', 'Z', 'R', 'F', 'W', 'N'], 2: ['W', 'P', 'Q', 'G', 'S'], 3: ['W', 'R', 'V', 'Q', 'F', 'N', 'J', 'C'], 4: ['F', 'Z', 'P', 'C', 'G', 'D', 'L'], 5: ['T', 'P', 'S'], 6: ['H', 'D', 'F', 'W', 'R', 'L'], 7: ['Z', 'N', 'D', 'C'], 8: ['W', 'N', 'R', 'F', 'V', 'S', 'J', 'Q'], 9: ['R', 'M', 'S', 'G', 'Z', 'W', 'V']}

```

Then I wrote a function to parse the instructions:

```
def parse_instruction(instruction):
    instruction = instruction[5:] # remove the word "move" and the space in the beginning
    how_many_we_movin = int(instruction.split(" from ")[0])
    the_rest = instruction.split(" from ")[1]
    source_column = int(the_rest.split(" to ")[0])
    destination_column = int(the_rest.split(" to ")[1])
    
    for i in range(1, how_many_we_movin+1):
        # get value of box and pop it out of the src stack
        box_value = map_2d_ready_to_move[source_column].pop() 
        # append the value of the box to the destination column
        map_2d_ready_to_move[destination_column].append(box_value)
```

I am holding the 2d map into a global variable so that it can be accessed while processing the instructions, instead of passing it around.

In the main function I put calls to the parsers:

```
map_2d_ready_to_move = parse_2d_input(map_2d)
    
for instr in instructions:
	parse_instruction(instr)
	
print(map_2d_ready_to_move)
```

And we're ready!! I just manually entered the few letters into the AoC answer field, fully capital letters, no spaces, no other symbols, as described in the task, and solved the problem. Or at least, part 1...

For part 2, we notice we have the exact same task, except we aren't looking for a LILO sort of data structure, but instead, something that will act as a queue rather than a stack.

However, instead of thinking how to write a new implementation, the easiest way to get the result done is by creating one extra container, which is going to temporarily hold the boxes being moved, in between popping them out of the source and adding them to the destination column.

This will make things easier because we already have elements in each of the column and we can't directly just append things at the front.

In `parse_instruction`, I make the following changes:

```
    box_batch = []
    for i in range(1, how_many_we_movin+1):
        # get value of box and pop it out of the src stack
        box_value = map_2d_ready_to_move[source_column].pop() 
        # append the value into the box batch
        box_batch.append(box_value)
        
    for j in range(1, how_many_we_movin+1):
        # get value of box and pop it out of the src stack
        box_value = box_batch.pop() 
        # append the value of the box to the destination column
        map_2d_ready_to_move[destination_column].append(box_value)
```

And voila!! It works!!

This task was definitely more time consuming than the rest due to the input parsing, but it was really worth it!